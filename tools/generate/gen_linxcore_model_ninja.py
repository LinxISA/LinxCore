#!/usr/bin/env python3
"""Generate a Ninja build file for pycircuit-generated LinxCore model objects.

Inputs:
  - generated/cpp/linxcore_top/cpp_compile_manifest.json
  - environment variables (CXX, flags, include paths)

Outputs:
  - generated/cpp/linxcore_top/build_model.ninja

This is intended to be called by build_linxcore_model_objects.sh.
"""

from __future__ import annotations

import json
import os
from pathlib import Path


def _q(s: str) -> str:
    # ninja escaping: spaces and colons
    return s.replace("$", "$$").replace(":", "$:").replace(" ", "$ ")


def main() -> int:
    root_dir = Path(os.environ["ROOT_DIR"]).resolve()
    gen_cpp_dir = Path(os.environ["GEN_CPP_DIR"]).resolve()
    gen_obj_dir = Path(os.environ["GEN_OBJ_DIR"]).resolve()
    manifest_path = Path(os.environ["CPP_MANIFEST"]).resolve()

    cxx = os.environ.get("CXX_BIN", os.environ.get("CXX", "clang++"))
    flags = os.environ.get("MODEL_CXXFLAGS", "-O3 -DNDEBUG")

    includes = [
        os.environ["PYC_COMPAT_INCLUDE"],
        os.environ["PYC_API_INCLUDE"],
        os.path.join(os.environ["PYC_ROOT"], "runtime"),
        os.path.join(os.environ["PYC_ROOT"], "runtime", "cpp"),
        str(gen_cpp_dir),
    ]

    sysroot = os.environ.get("PYC_TB_SYSROOT", "")
    if not sysroot and os.uname().sysname == "Darwin":
        # best-effort; shell wrapper typically fills this already
        pass

    if not manifest_path.exists():
        raise SystemExit(f"error: manifest missing: {manifest_path}")

    data = json.loads(manifest_path.read_text(encoding="utf-8"))
    sources: list[Path] = []
    for entry in data.get("sources", []):
        rel = entry.get("path")
        if not rel:
            continue
        p = Path(rel)
        if not p.is_absolute():
            p = gen_cpp_dir / p
        sources.append(p)

    if not sources:
        raise SystemExit(f"error: no sources in manifest: {manifest_path}")

    out_ninja = gen_cpp_dir / "build_model.ninja"
    gen_obj_dir.mkdir(parents=True, exist_ok=True)

    cflags = ["-std=c++17"] + flags.split()
    for inc in includes:
        cflags += ["-I", inc]
    if os.uname().sysname == "Darwin" and sysroot:
        cflags += ["-isysroot", sysroot]
        if Path(cxx).name.find("clang") != -1:
            cflags += ["-isystem", str(Path(sysroot) / "usr/include/c++/v1")]

    # depfiles: only for gcc/clang; safe to pass to clang.
    depflags = ["-MMD", "-MF", "$out.d"]

    lines: list[str] = []
    lines.append("# Autogenerated. Do not edit.\n")
    lines.append(f"cxx = {_q(cxx)}\n")
    lines.append(f"cxxflags = {_q(' '.join(cflags))}\n")
    lines.append("rule cxx\n")
    lines.append("  command = $cxx $cxxflags " + " ".join(depflags) + " -c $in -o $out.tmp && mv -f $out.tmp $out\n")
    lines.append("  depfile = $out.d\n")
    lines.append("  deps = gcc\n")
    lines.append("  description = CXX $out\n")
    lines.append("\n")

    objs: list[Path] = []
    for src in sources:
        stem = src.as_posix().replace("/", "__")
        if stem.endswith(".cpp"):
            stem = stem[:-4]
        obj = gen_obj_dir / f"{stem}.o"
        objs.append(obj)
        lines.append(f"build {_q(str(obj))}: cxx {_q(str(src))}\n")

    lines.append("\n")
    lines.append(f"build model_objects: phony {' '.join(_q(str(o)) for o in objs)}\n")

    out_ninja.write_text("".join(lines), encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
